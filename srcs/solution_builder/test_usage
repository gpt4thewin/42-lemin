static int	usage(char *av[])
{
	ft_printf(
		"usage: %s [-hvsg] [-i <filename>] [-o <filename>]\n"
		"  -h              Show this help.\n"
		"  -s              Execute the program step by step (imply -v).\n"
		"  -v              Output some verbose to the standard error output.\n"
		"  -g              Enable the ncurses GUI.\n"
		"  -i <filename>   Use `filename` as input.\n"
		"  -o <filename>   Output standard output to `filename`.\n",
		av[0]);
	return (EXIT_FAILURE);
}

static int	finalize(t_lemin *lemin, t_map *rooms, int ecode)
{
	if (lemin->input != STDIN_FILENO)
		close(lemin->input);
	if (lemin->output != STDOUT_FILENO)
		close(lemin->output);
	ft_sdsdtor(&lemin->map);
	ft_mapdtor(rooms, (t_dtor)ft_pfree, (t_dtor)lemin_vertexdtor);
	return (ecode);
}

static int	tryopen(t_lemin *lemin, char const *filename, int flags, int *out)
{
	int fd;

	if (*out > 2)
		close(*out);
	if ((fd = open(filename, flags, 0666)) < 0)
		return (lemin_error(lemin, "%s: %m\n", filename));
	*out = fd;
	return (YEP);
}

static int	opt(t_lemin *l, int ac, char *av[])
{
	int opt;

	g_optind = 1;
	l->prg = av[0];
	while ((opt = ft_getopt(ac, av, "hvsgi:o:")) != WUT)
		if (opt == 'h' || !ft_strchr("vsgio", opt))
			return (NOP);
		else if (opt == 'v')
			l->options |= OPT_VERB;
		else if (opt == 's')
			l->options |= (OPT_STEP | OPT_VERB);
		else if (opt == 'g')
			l->options |= OPT_NGUI;
		else if (opt == 'i')
		{
			if (tryopen(l, g_optarg, O_RDONLY, &l->input))
				return (NOP);
		}
		else if (opt == 'o')
		{
			if (tryopen(l, g_optarg, O_WRONLY | O_CREAT | O_TRUNC, &l->output))
				return (NOP);
		}
	return (g_optind < ac);
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ush/env.h                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alucas- <alucas-@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2017/11/07 09:52:30 by cmalfroy          #+#    #+#             */
/*   Updated: 2017/12/06 12:00:10 by alucas-          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft/getopt.h"

#define BADCH '?'
#define BADARG ':'
#define EMSG ""
#define ERR0 "%s: %c: illegal option\n"
#define ERR1 "%s: %c: option requires an argument\n"

char		*g_optarg = 0;
int			g_optind = 1;
int			g_optopt = 0;
int			g_opterr = 1;
static int	g_optreset = 0;
static char	*g_place = EMSG;

static inline int	getopt2(char const *s, int ac, char *av[], char const *fmt)
{
	if (g_optopt == ':' || (s = ft_strchr(fmt, g_optopt)) == NULL)
	{
		!*g_place ? ++g_optind : 0;
		g_opterr && *fmt != ':' ? ft_dprintf(2, ERR0, av[0], g_optopt) : 0;
		return (BADCH);
	}
	if (s[1] != ':' && !(g_optarg = NULL))
		!*g_place ? ++g_optind : 0;
	else
	{
		if (*g_place)
			g_optarg = g_place;
		else if (ac > ++g_optind)
			g_optarg = av[g_optind];
		else
		{
			if ((g_place = EMSG) && *fmt == ':')
				return (BADARG);
			g_opterr ? ft_dprintf(STDERR_FILENO, ERR1, av[0], g_optopt) : 0;
			return (BADCH);
		}
		g_place = EMSG;
		++g_optind;
	}
	return (g_optopt);
}

int					ft_getopt(int ac, char *av[], char const *fmt)
{
	char *s;

	s = NULL;
	if (g_optreset || *g_place == 0)
	{
		g_optreset = 0;
		g_place = av[g_optind];
		if ((g_optind >= ac || *g_place++ != '-') && (g_place = EMSG))
			return (WUT);
		g_optopt = *g_place++;
		if (g_optopt == '-' && *g_place == 0 && (g_place = EMSG) && ++g_optind)
			return (WUT);
		if (g_optopt == 0 && (g_place = EMSG))
		{
			if (ft_strchr(fmt, '-') == NULL)
				return (WUT);
			else
				g_optopt = '-';
		}
	}
	else
		g_optopt = *g_place++;
	return (getopt2(s, ac, av, fmt));
}


int			main(int ac, char *av[])
{
	if (opt(&lemin, ac, av))
	{
		if ((g_optind < ac) && (lemin.options & OPT_VERB))
			lemin_error(&lemin, "%s: Unexpected argument.\n", av[g_optind]);
		finalize(&lemin, &graph, EXIT_FAILURE);
		return (usage(av));
	}
